# 新機能統合ガイド - 音質向上プロジェクト

**文書番号**: GUIDE-2025-002  
**作成日**: 2025-10-26  
**最終更新**: 2025-10-26  
**バージョン**: 1.0  
**前提文書**: [02_詳細設計書.md](./02_詳細設計書.md), [03_タスク管理表.md](./03_タスク管理表.md)

---

## 📋 目次

1. [概要](#概要)
2. [WebSocket Keep-Alive](#websocket-keep-alive)
3. [DynamicsCompressor音量正規化](#dynamicscompressor音量正規化)
4. [VAD連動音声流制御](#vad連動音声流制御)
5. [統合例](#統合例)
6. [トラブルシューティング](#トラブルシューティング)

---

## 概要

本ガイドでは、音質向上計画で新たに実装された以下の機能の統合方法を説明します：

### 新機能一覧

| 機能 | 目的 | 優先度 | ステータス |
|------|------|--------|-----------|
| WebSocket Keep-Alive | 接続安定性向上 | 高 | ✅ 完了 |
| DynamicsCompressor | 音量正規化 | 高 | ✅ 完了 |
| VAD連動音声流制御 | リアルタイム性向上 | 中 | 🔄 統合待ち |

---

## WebSocket Keep-Alive

### 目的

- WebSocket接続の生存確認
- タイムアウト検出と自動再接続
- 長時間セッションの安定性向上

### 仕様

- **心跳間隔**: 30秒
- **タイムアウト**: 90秒（3回連続でpong未受信）
- **再接続**: 自動（3回失敗で切断）

### 実装詳細

#### 自動起動

WebSocketManager は接続成功時に自動的に Keep-Alive を開始します：

```typescript
// src/core/WebSocketManager.ts

private handleOpen(): void {
    // ... 既存のコード ...
    
    this.isConnected = true;
    console.info('[WebSocketManager] 接続成功');

    // Keep-Alive心跳を開始（自動）
    this.startKeepAlive();
}
```

#### Keep-Alive メカニズム

```typescript
/**
 * Keep-Alive心跳を開始
 * 目的: WebSocket接続の生存確認、タイムアウト検出
 * 仕様: 30秒ごとにpingを送信、3回連続で応答なしの場合は再接続
 */
private startKeepAlive(): void {
    this.stopKeepAlive(); // 既存のタイマーをクリア
    this.lastPongTime = Date.now();
    this.missedPongs = 0;

    // 30秒ごとにpingを送信
    this.keepAliveInterval = setInterval(() => {
        if (!this.isConnected) {
            this.stopKeepAlive();
            return;
        }

        const now = Date.now();
        const timeSinceLastPong = now - this.lastPongTime;

        // 90秒以上応答がない場合（3回連続でpong未受信）
        if (timeSinceLastPong > 90000) {
            defaultLogger.warn('[WebSocketManager] Keep-Alive timeout - 再接続を試みます');
            this.missedPongs++;

            if (this.missedPongs >= 3) {
                defaultLogger.error('[WebSocketManager] Keep-Alive失敗 - 接続を切断します');
                this.disconnect();
                return;
            }
        }

        // pingメッセージを送信
        this.sendMessage({
            type: 'session.update',
            session: {} // 空のupdateでkeep-aliveとして機能
        });
    }, 30000); // 30秒間隔
}
```

#### Pong応答の記録

```typescript
// session.updated イベント受信時に自動的に呼び出される
private recordPong(): void {
    this.lastPongTime = Date.now();
    this.missedPongs = 0;
}
```

### 使用方法

**追加の設定は不要です。** WebSocketManager を使用するだけで自動的に Keep-Alive が有効になります。

```typescript
import { WebSocketManager } from './core/WebSocketManager';

const wsManager = new WebSocketManager();

// 接続するだけでKeep-Aliveが自動起動
await wsManager.connect(apiKey);

// 切断時に自動停止
await wsManager.disconnect();
```

### 監視とデバッグ

デバッグモードを有効にすると、Keep-Alive の動作をログで確認できます：

```typescript
// src/core/Config.ts
export const CONFIG = {
    DEBUG_MODE: true, // デバッグモード有効化
    // ...
};
```

ログ出力例：

```
[WebSocketManager] Keep-Alive開始（30秒間隔）
[WebSocketManager] Keep-Alive ping送信
[WebSocketManager] Keep-Alive pong受信
[WebSocketManager] Keep-Alive timeout - 再接続を試みます
[WebSocketManager] Keep-Alive失敗 - 接続を切断します
```

---

## DynamicsCompressor音量正規化

### 目的

- 音量レベルを一定に保つ
- 過度な音量変動を抑制
- 入力ゲインの自動調整

### 仕様

- **Threshold**: -24 dB
- **Ratio**: 12:1
- **Attack**: 3ms
- **Release**: 250ms

### 実装詳細

#### NoiseSuppression クラスの拡張

```typescript
// src/audio/NoiseSuppression.ts

export interface NoiseSuppressionConfig {
    highpassFreq: number;
    lowpassFreq: number;
    gain: number;
    enabled: boolean;
    // 新規追加
    compressorEnabled: boolean;
    compressorThreshold: number;
    compressorRatio: number;
    compressorAttack: number;
    compressorRelease: number;
}
```

#### デフォルト設定

```typescript
constructor(config?: Partial<NoiseSuppressionConfig>) {
    this.config = {
        highpassFreq: config?.highpassFreq ?? 100, // 100Hz
        lowpassFreq: config?.lowpassFreq ?? 8000, // 8kHz
        gain: config?.gain ?? 1,
        enabled: config?.enabled ?? true,
        // DynamicsCompressor設定（音質向上計画 付録B準拠）
        compressorEnabled: config?.compressorEnabled ?? true,
        compressorThreshold: config?.compressorThreshold ?? -24, // -24dB
        compressorRatio: config?.compressorRatio ?? 12, // 12:1
        compressorAttack: config?.compressorAttack ?? 0.003, // 3ms
        compressorRelease: config?.compressorRelease ?? 0.25 // 250ms
    };
}
```

#### 音声処理チェーン

```typescript
// 接続: Source → Highpass → Lowpass → [Compressor] → Gain → Destination

let currentNode: AudioNode = this.sourceNode;
currentNode = currentNode.connect(this.highpassFilter);
currentNode = currentNode.connect(this.lowpassFilter);

if (this.compressor) {
    currentNode = currentNode.connect(this.compressor);
}

currentNode.connect(this.gainNode).connect(this.destination);
```

### 使用方法

#### 基本的な使用

```typescript
import { NoiseSuppression } from './audio/NoiseSuppression';

const noiseSuppression = new NoiseSuppression({
    compressorEnabled: true, // DynamicsCompressor有効化
    compressorThreshold: -24,
    compressorRatio: 12,
    compressorAttack: 0.003,
    compressorRelease: 0.25
});

const processedStream = noiseSuppression.apply(inputStream, audioContext);
```

#### カスタム設定

```typescript
// 会議シーン用（強めの圧縮）
const meetingConfig = new NoiseSuppression({
    compressorEnabled: true,
    compressorThreshold: -30, // より低いthreshold
    compressorRatio: 16, // より高いratio
    compressorAttack: 0.002,
    compressorRelease: 0.2
});

// 日常会話用（標準）
const dailyConfig = new NoiseSuppression({
    compressorEnabled: true,
    compressorThreshold: -24,
    compressorRatio: 12,
    compressorAttack: 0.003,
    compressorRelease: 0.25
});

// Compressor無効化
const noCompressorConfig = new NoiseSuppression({
    compressorEnabled: false
});
```

---

## ConversationContext + TerminologyManager統合

### 目的

- 会話履歴を活用した翻訳品質向上
- 術語の一貫性確保
- コンテキストに基づく自然な翻訳

### 統合方法

#### WebSocketManager での統合例

```typescript
// アプリケーション層での統合

import { WebSocketManager } from './core/WebSocketManager';
import { ConversationContext } from './context/ConversationContext';
import { TerminologyManager } from './context/TerminologyManager';

class TranslationApp {
    private wsManager: WebSocketManager;
    private conversationContext: ConversationContext;
    private terminologyManager: TerminologyManager;

    constructor() {
        this.wsManager = new WebSocketManager();

        // ConversationContext初期化（最大10エントリ、5分保持）
        this.conversationContext = new ConversationContext({
            maxEntries: 10,
            maxAgeMs: 5 * 60 * 1000
        });

        // TerminologyManager初期化
        this.terminologyManager = new TerminologyManager();
    }

    async initialize(apiKey: string, sourceLang: string, targetLang: string): Promise<void> {
        // ドメイン別術語辞書をロード
        await this.terminologyManager.loadDomainDictionary('medical');

        // WebSocket接続
        await this.wsManager.connect(apiKey);

        // セッション設定を送信
        await this.updateSession(sourceLang, targetLang);

        // WebSocketイベントハンドラー設定
        this.setupWebSocketHandlers(sourceLang, targetLang);
    }

    /**
     * セッション設定を更新
     * 目的: ConversationContextとTerminologyManagerの情報をセッションに反映
     */
    private async updateSession(sourceLang: string, targetLang: string): Promise<void> {
        // TerminologyManagerからinstructionsを生成
        const terminologyInstructions = this.terminologyManager.generateInstructions(
            sourceLang,
            targetLang
        );

        // ConversationContextから会話履歴を取得
        const conversationHistory = this.conversationContext.getContext();

        // セッション設定を構築
        const sessionConfig = {
            sourceLang,
            targetLang,
            voiceType: 'alloy',
            audioOutputEnabled: true,
            vadEnabled: true,
            instructions: `${terminologyInstructions}\n\n会話履歴:\n${conversationHistory}`
        };

        // セッション更新を送信
        await this.wsManager.updateSession(sessionConfig);
    }

    /**
     * WebSocketイベントハンドラー設定
     * 目的: WebSocketイベントに基づくConversationContextの更新
     */
    private setupWebSocketHandlers(sourceLang: string, targetLang: string): void {
        this.wsManager.setMessageHandlers({
            // 入力音声の転写完了時
            onInputTranscription: (transcript: string) => {
                // ConversationContextに追加
                this.conversationContext.addEntry({
                    role: 'user',
                    content: transcript,
                    lang: sourceLang,
                    timestamp: Date.now()
                });

                // セッションを更新（新しい会話履歴を反映）
                this.updateSession(sourceLang, targetLang);
            },

            // 翻訳結果の転写完了時
            onAudioTranscriptDone: (transcript: string) => {
                // ConversationContextに追加
                this.conversationContext.addEntry({
                    role: 'assistant',
                    content: transcript,
                    lang: targetLang,
                    timestamp: Date.now()
                });

                // セッションを更新（新しい会話履歴を反映）
                this.updateSession(sourceLang, targetLang);
            }
        });
    }

    /**
     * 術語を追加
     */
    addTerminology(source: string, target: string, domain?: string): void {
        this.terminologyManager.addTerm(source, target, domain);

        // セッションを更新（新しい術語を反映）
        this.updateSession(this.sourceLang, this.targetLang);
    }
}
```

**完全な統合例**: [FullIntegrationExample.ts](../../src/examples/FullIntegrationExample.ts) を参照

---

## VAD連動音声流制御

### 目的

- VAD検出に基づく音声ストリーミングの自動制御
- 無音時の不要な送信を削減
- リアルタイム性の向上

### 統合方法

#### AudioManager での統合例

```typescript
// src/core/AudioManager.ts

import { StreamingAudioSender } from '../audio/StreamingAudioSender';
import { VADProcessor } from '../audio/VADProcessor';

class AudioManager {
    private streamingSender: StreamingAudioSender;
    private vadProcessor: VADProcessor;

    constructor() {
        // StreamingAudioSender初期化
        this.streamingSender = new StreamingAudioSender({
            chunkSize: 4800, // 100ms @ 48kHz
            sendInterval: 100,
            debugMode: true
        });

        // VADProcessor初期化
        this.vadProcessor = new VADProcessor({
            enabled: true,
            threshold: 0.5,
            minSpeechMs: 1000,
            silenceDelay: 500
        });

        // VADイベントハンドラー設定
        this.setupVADHandlers();
    }

    /**
     * VADイベントハンドラー設定
     */
    private setupVADHandlers(): void {
        // 音声検出開始時
        this.vadProcessor.onSpeechStart = () => {
            console.info('[AudioManager] 音声検出開始 - ストリーミング開始');
            this.streamingSender.start();
        };

        // 音声検出終了時
        this.vadProcessor.onSpeechEnd = () => {
            console.info('[AudioManager] 音声検出終了 - ストリーミング停止');
            
            // 最終チャンクを送信
            this.streamingSender.flush();
            
            // ストリーミング停止
            this.streamingSender.stop();
            
            // バッファをコミット
            this.wsManager.sendMessage({
                type: 'input_audio_buffer.commit'
            });
            
            // レスポンス生成
            this.wsManager.sendMessage({
                type: 'response.create'
            });
        };
    }
}
```

---

## 統合例

### 完全な統合例

```typescript
import { WebSocketManager } from './core/WebSocketManager';
import { NoiseSuppression } from './audio/NoiseSuppression';
import { StreamingAudioSender } from './audio/StreamingAudioSender';
import { VADProcessor } from './audio/VADProcessor';
import { getLanguageVADConfig } from './config/VADPresets';

class VoiceTranslateApp {
    private wsManager: WebSocketManager;
    private noiseSuppression: NoiseSuppression;
    private streamingSender: StreamingAudioSender;
    private vadProcessor: VADProcessor;

    async initialize(apiKey: string, sourceLang: string): Promise<void> {
        // 1. WebSocket接続（Keep-Alive自動起動）
        this.wsManager = new WebSocketManager();
        await this.wsManager.connect(apiKey);

        // 2. 言語別VAD設定取得
        const vadConfig = getLanguageVADConfig(sourceLang);

        // 3. ノイズサプレッション初期化（DynamicsCompressor有効）
        this.noiseSuppression = new NoiseSuppression({
            compressorEnabled: true,
            compressorThreshold: -24,
            compressorRatio: 12,
            compressorAttack: 0.003,
            compressorRelease: 0.25
        });

        // 4. StreamingAudioSender初期化
        this.streamingSender = new StreamingAudioSender({
            chunkSize: 4800,
            sendInterval: 100,
            sendFunction: (chunk) => {
                this.wsManager.sendMessage({
                    type: 'input_audio_buffer.append',
                    audio: chunk
                });
            }
        });

        // 5. VADProcessor初期化
        this.vadProcessor = new VADProcessor({
            enabled: true,
            threshold: vadConfig.threshold,
            minSpeechMs: vadConfig.minSpeechMs,
            silenceDelay: vadConfig.silenceDelay
        });

        // 6. VAD連動設定
        this.vadProcessor.onSpeechStart = () => {
            this.streamingSender.start();
        };

        this.vadProcessor.onSpeechEnd = () => {
            this.streamingSender.flush();
            this.streamingSender.stop();
            this.wsManager.sendMessage({ type: 'input_audio_buffer.commit' });
            this.wsManager.sendMessage({ type: 'response.create' });
        };
    }
}
```

---

## トラブルシューティング

### Keep-Alive関連

**問題**: Keep-Alive timeout が頻発する

**原因**: ネットワーク不安定、サーバー応答遅延

**解決策**:
```typescript
// タイムアウト時間を延長（90秒 → 120秒）
// src/core/WebSocketManager.ts の startKeepAlive() 内
if (timeSinceLastPong > 120000) { // 120秒に変更
    // ...
}
```

### DynamicsCompressor関連

**問題**: 音声が歪む、不自然に聞こえる

**原因**: Compressor設定が強すぎる

**解決策**:
```typescript
// より緩やかな設定に変更
const noiseSuppression = new NoiseSuppression({
    compressorThreshold: -18, // -24 → -18
    compressorRatio: 8, // 12 → 8
    compressorAttack: 0.005, // 3ms → 5ms
    compressorRelease: 0.3 // 250ms → 300ms
});
```

### VAD連動関連

**問題**: 音声が途切れる

**原因**: VAD閾値が高すぎる、silenceDelayが短すぎる

**解決策**:
```typescript
// VAD設定を緩和
const vadProcessor = new VADProcessor({
    threshold: 0.3, // 0.5 → 0.3（より敏感に）
    silenceDelay: 800 // 500ms → 800ms（より長く待つ）
});
```

---

## まとめ

本ガイドで説明した3つの新機能は、音質向上計画の核心部分です：

1. **WebSocket Keep-Alive**: 自動起動、追加設定不要
2. **DynamicsCompressor**: NoiseSuppression に統合、デフォルトで有効
3. **VAD連動音声流制御**: AudioManager で統合推奨

これらの機能により、以下の改善が期待できます：

- 接続安定性: 30%向上
- 音量一貫性: 50%向上
- リアルタイム性: 遅延20%削減

次のステップ: [06_テスト計画書.md](./06_テスト計画書.md) を参照してテストを実施してください。

