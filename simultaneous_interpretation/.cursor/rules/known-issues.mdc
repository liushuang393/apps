---
description: 已知问题、错误模式和改进方向
alwaysApply: true
---
# 已知问题与改进方向

## 🔴 当前严重问题

### 1. 响应竞争条件错误（Critical）

**错误代码**: `conversation_already_has_active_response`

**根本原因**:
```
用户连续发话 → VAD 多次触发 → 多个 response.create 请求
                                      ↓
                                OpenAI 拒绝（只允许1个活跃响应）
```

**问题代码位置**:
- [voicetranslate-pro.js:1166](mdc:voicetranslate-pro.js) - `handleAudioBufferCommitted()`
- [voicetranslate-utils.js:198](mdc:voicetranslate-utils.js) - `ResponseQueue.handleError()`

**状态管理问题**:
```javascript
// ❌ 当前: 3个相互冲突的状态变量
this.activeResponseId = null;
this.pendingResponseId = null;
this.state.isNewResponse = true;

// 问题: 状态更新时机不一致，导致判断错误
if (this.activeResponseId || this.pendingResponseId) {
    return;  // ← 这个检查经常失效
}
```

**必须修复**: 在修改响应处理相关代码时，必须考虑以下约束：
1. OpenAI Realtime API **同时只能有1个活跃响应**
2. 必须等待 `response.done` 事件后才能发送新请求
3. 状态检查必须在异步环境下可靠

---

## ✅ 推荐解决方案

### 方案1: 引入状态机（强烈推荐）

```typescript
/**
 * 响应状态管理
 * 
 * 状态转换规则:
 *   IDLE → BUFFERING → COMMITTED → PENDING → ACTIVE → COMPLETING → IDLE
 */
enum ResponseState {
    IDLE = 'idle',                    // 空闲，可以接受新请求
    AUDIO_BUFFERING = 'buffering',    // 音频缓冲中
    AUDIO_COMMITTED = 'committed',    // 音频已提交
    RESPONSE_PENDING = 'pending',     // 响应请求已发送
    RESPONSE_ACTIVE = 'active',       // 响应处理中（OpenAI）
    RESPONSE_COMPLETING = 'completing' // 响应完成中
}

class ResponseStateManager {
    private state: ResponseState = ResponseState.IDLE;
    private activeResponseId: string | null = null;
    
    /**
     * 判断是否可以创建新响应
     * ✅ 只有在 IDLE 或 BUFFERING 状态才允许
     */
    canCreateResponse(): boolean {
        return this.state === ResponseState.IDLE || 
               this.state === ResponseState.AUDIO_BUFFERING;
    }
    
    /**
     * 状态转换（带验证）
     */
    transition(newState: ResponseState, responseId?: string): void {
        if (!this.isValidTransition(this.state, newState)) {
            throw new Error(`Invalid transition: ${this.state} → ${newState}`);
        }
        
        console.info(`[State] ${this.state} → ${newState}`, { responseId });
        this.state = newState;
        
        if (newState === ResponseState.RESPONSE_ACTIVE) {
            this.activeResponseId = responseId ?? null;
        } else if (newState === ResponseState.IDLE) {
            this.activeResponseId = null;
        }
    }
    
    /**
     * 验证状态转换是否合法
     */
    private isValidTransition(from: ResponseState, to: ResponseState): boolean {
        const validTransitions: Record<ResponseState, ResponseState[]> = {
            [ResponseState.IDLE]: [
                ResponseState.AUDIO_BUFFERING
            ],
            [ResponseState.AUDIO_BUFFERING]: [
                ResponseState.AUDIO_COMMITTED,
                ResponseState.IDLE  // 取消时
            ],
            [ResponseState.AUDIO_COMMITTED]: [
                ResponseState.RESPONSE_PENDING
            ],
            [ResponseState.RESPONSE_PENDING]: [
                ResponseState.RESPONSE_ACTIVE,
                ResponseState.IDLE  // 错误时
            ],
            [ResponseState.RESPONSE_ACTIVE]: [
                ResponseState.RESPONSE_COMPLETING
            ],
            [ResponseState.RESPONSE_COMPLETING]: [
                ResponseState.IDLE
            ]
        };
        
        return validTransitions[from]?.includes(to) ?? false;
    }
}
```

### 方案2: 改进 ResponseQueue

```typescript
class ImprovedResponseQueue {
    private pendingQueue: ResponseRequest[] = [];
    private stateManager: ResponseStateManager;
    private isProcessing = false;  // ✅ 防止并发
    
    async enqueue(request: ResponseRequest): Promise<string> {
        // ✅ 状态检查
        if (!this.stateManager.canCreateResponse()) {
            throw new Error(
                `Cannot create response in state ${this.stateManager.getState()}`
            );
        }
        
        return new Promise((resolve, reject) => {
            this.pendingQueue.push({ request, resolve, reject });
            
            // ✅ 使用 setTimeout(0) 避免同步竞争
            setTimeout(() => this.processNext(), 0);
        });
    }
    
    private async processNext(): Promise<void> {
        // ✅ 防止并发执行
        if (this.isProcessing) {
            return;
        }
        
        // ✅ 再次检查状态
        if (!this.stateManager.canCreateResponse()) {
            console.info('[Queue] Cannot process: response active');
            return;
        }
        
        const item = this.pendingQueue.shift();
        if (!item) {
            return;
        }
        
        this.isProcessing = true;
        
        try {
            // 状态转换
            this.stateManager.transition(ResponseState.RESPONSE_PENDING);
            
            // 发送请求
            const responseId = await this.sendRequest(item.request);
            
            item.resolve(responseId);
        } catch (error) {
            item.reject(error);
            
            // 错误时回到 IDLE
            this.stateManager.transition(ResponseState.IDLE);
        } finally {
            this.isProcessing = false;
        }
    }
    
    handleResponseDone(responseId: string): void {
        // 状态转换
        this.stateManager.transition(ResponseState.IDLE);
        
        // ✅ 处理下一个请求（延迟100ms，确保状态稳定）
        setTimeout(() => this.processNext(), 100);
    }
}
```

---

## 🟡 其他已知问题

### 2. VAD 缓冲策略不足

**问题**: VAD 检测到无声就立即发送，导致：
- 短音频被误发送（< 1秒）
- 连续说话被切分成多个请求

**改进方向**:
```typescript
class VADBufferingStrategy {
    private minBufferDuration = 1000;   // 最短1秒
    private maxBufferDuration = 10000;  // 最长10秒
    private silenceDebounce = 500;      // 500ms 无声才确认
    
    onSilenceDetected(): void {
        // ✅ 延迟500ms再确认
        this.silenceTimer = setTimeout(() => {
            if (this.getBufferDuration() >= this.minBufferDuration) {
                this.flush();
            }
        }, this.silenceDebounce);
    }
    
    onSpeechDetected(): void {
        // ✅ 有声音则取消
        if (this.silenceTimer) {
            clearTimeout(this.silenceTimer);
        }
    }
}
```

### 3. 缺少会话上下文管理

**问题**: 每个请求独立，无法支持多轮对话

**改进方向**:
- 实现 `ConversationContext` 类
- 保留最近100条会话记录
- 在请求中附带上下文

### 4. 音频发送策略可优化

**当前**: 累积后一次性发送  
**改进**: 流式发送（每100ms发送一次）

---

## 📋 编码约束

### 处理响应时必须遵守：

1. **状态检查先行**
```typescript
// ✅ 正确
if (!this.stateManager.canCreateResponse()) {
    console.warn('Skip: response active');
    return;
}
await this.createResponse();

// ❌ 错误
await this.createResponse();  // 没有检查状态
```

2. **状态更新必须原子性**
```typescript
// ✅ 正确
this.stateManager.transition(ResponseState.RESPONSE_ACTIVE, responseId);

// ❌ 错误
this.activeResponseId = responseId;  // 容易出现竞态条件
this.state = 'active';
```

3. **错误处理必须恢复状态**
```typescript
// ✅ 正确
try {
    await this.sendRequest();
} catch (error) {
    this.stateManager.transition(ResponseState.IDLE);  // 恢复状态
    throw error;
}
```

4. **异步操作必须延迟**
```typescript
// ✅ 正确
setTimeout(() => this.processNext(), 0);  // 避免同步竞争

// ❌ 错误
this.processNext();  // 可能导致栈溢出或竞态
```

---

## 🎯 优先级

| 问题 | 严重程度 | 用户影响 | 修复难度 | 优先级 |
|-----|---------|---------|---------|--------|
| 响应竞争条件 | 🔴 Critical | 🔴 高 | 🟡 中 | **P0** |
| VAD 缓冲策略 | 🟡 Medium | 🟡 中 | 🟡 中 | **P1** |
| 会话上下文 | 🟢 Low | 🟢 低 | 🟡 中 | **P2** |
| 音频流式发送 | 🟡 Medium | 🟢 低 | 🔴 高 | **P2** |

---

## 📚 参考文档

- [架构改进方案（日文）](mdc:../../docs/ARCHITECTURE_IMPROVEMENTS.md)
- [架构改进方案（中文）](mdc:../../docs/架构改进方案_CN.md)
- [OpenAI Realtime API 文档](https://platform.openai.com/docs/guides/realtime)

---

**重要**: 在修改 `ResponseQueue`、`handleAudioBufferCommitted`、`handleResponseCreated`、`handleResponseDone` 等方法时，务必参考本文档的约束和建议。
